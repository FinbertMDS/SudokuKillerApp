// ÄÃ£ cáº­p nháº­t: Ã´ Ä‘Æ°á»£c chá»n cÃ³ lá»›p ná»n riÃªng khÃ´ng che border hoáº·c nÃ©t Ä‘á»©t SVG
import React, { useState } from 'react';
import { Animated, StyleSheet, Text, TouchableOpacity, View } from 'react-native';
import Svg, { Rect } from 'react-native-svg';
import MaterialCommunityIcons from 'react-native-vector-icons/MaterialCommunityIcons';

const BOARD_SIZE = 9;
const CELL_SIZE = 40;

const BoardScreen = ({ board: initialBoard, cages }: { board: number[][], cages: { id: number, cells: [number, number][], sum: number }[] }) => {
  const [selectedCell, setSelectedCell] = useState<{ row: number; col: number } | null>(null);
  const [board, setBoard] = useState<number[][]>(initialBoard);
  const [notes, setNotes] = useState<string[][][]>(
    Array.from({ length: BOARD_SIZE }, () =>
      Array.from({ length: BOARD_SIZE }, () => [])
    )
  );
  const [noteMode, setNoteMode] = useState<boolean>(false);
  const [history, setHistory] = useState<number[][][]>([]);

  const [highlightAnims, setHighlightAnims] = useState<Animated.Value[][]>(
    Array.from({ length: BOARD_SIZE }, () =>
      Array.from({ length: BOARD_SIZE }, () => new Animated.Value(0))
    )
  );

  const handleCellPress = (row: number, col: number) => {
    setSelectedCell({ row, col });

    // Reset all animated values to 0
    for (let r = 0; r < BOARD_SIZE; r++) {
      for (let c = 0; c < BOARD_SIZE; c++) {
        highlightAnims[r][c].setValue(0);
      }
    }

    // Animate highlight row left-to-right
    for (let i = 0; i < BOARD_SIZE; i++) {
      Animated.sequence([
        Animated.delay(i * 50),
        Animated.timing(highlightAnims[row][i], {
          toValue: 1,
          duration: 200,
          useNativeDriver: false,
        }),
        Animated.timing(highlightAnims[row][i], {
          toValue: 0,
          duration: 200,
          useNativeDriver: false,
        })
      ]).start();
    }

    // Animate highlight column top-to-bottom
    for (let j = 0; j < BOARD_SIZE; j++) {
      if (j !== row) {
        Animated.sequence([
          Animated.delay(j * 50),
          Animated.timing(highlightAnims[j][col], {
            toValue: 1,
            duration: 200,
            useNativeDriver: false,
          }),
          Animated.timing(highlightAnims[j][col], {
            toValue: 0,
            duration: 200,
            useNativeDriver: false,
          })
        ]).start();
      }
    }
  };

  const handleNumberPress = (num: number) => {
    if (!selectedCell) return;
    const { row, col } = selectedCell;

    saveHistory();

    if (noteMode) {
      const newNotes = [...notes];
      const cellNotes = newNotes[row][col];
      if (cellNotes.includes(num.toString())) {
        newNotes[row][col] = cellNotes.filter((n) => n !== num.toString());
      } else {
        newNotes[row][col] = [...cellNotes, num.toString()].sort();
      }
      setNotes(newNotes);
    } else {
      const newBoard = [...board];
      newBoard[row][col] = num;
      setBoard(newBoard);
      const newNotes = [...notes];
      newNotes[row][col] = [];
      setNotes(newNotes);
    }
  };

  const saveHistory = () => {
    const boardCopy = board.map(row => [...row]);
    setHistory(prev => [...prev, boardCopy]);
  };

  const handleUndo = () => {
    if (history.length === 0) return;
    const lastState = history[history.length - 1];
    setBoard(lastState);
    setHistory(prev => prev.slice(0, -1));
  };

  const handleClear = () => {
    if (!selectedCell) return;
    const { row, col } = selectedCell;
    saveHistory();
    const newBoard = [...board];
    newBoard[row][col] = 0;
    setBoard(newBoard);
    const newNotes = [...notes];
    newNotes[row][col] = [];
    setNotes(newNotes);
  };

  const isCellInSameRowOrColOrBox = (row: number, col: number) => {
    if (!selectedCell) return false;
    const selRow = selectedCell.row;
    const selCol = selectedCell.col;
    const inSameBox = Math.floor(selRow / 3) === Math.floor(row / 3) && Math.floor(selCol / 3) === Math.floor(col / 3);
    return selRow === row || selCol === col || inSameBox;
  };

  const getCageForCell = (row: number, col: number) => {
    return cages.find(cage => cage.cells.some(cell => cell[0] === row && cell[1] === col));
  };

  // Váº½ Ä‘Æ°á»ng nÃ©t Ä‘á»©t cho má»—i cage, dá»‹ch vÃ o trong 3px
  const renderCageOutlines = () => {
    return cages.map((cage) => {
      const rows = cage.cells.map(([r]) => r);
      const cols = cage.cells.map(([, c]) => c);
      const minRow = Math.min(...rows);
      const maxRow = Math.max(...rows);
      const minCol = Math.min(...cols);
      const maxCol = Math.max(...cols);

      const x = minCol * CELL_SIZE + 3;
      const y = minRow * CELL_SIZE + 3;
      const width = (maxCol - minCol + 1) * CELL_SIZE - 6;
      const height = (maxRow - minRow + 1) * CELL_SIZE - 6;

      return (
        <Rect
          key={`cage-${cage.id}`}
          x={x}
          y={y}
          width={width}
          height={height}
          stroke="gray"
          strokeDasharray="4,4"
          strokeWidth={1}
          fill="none"
        />
      );
    });
  };

  const renderCell = (row: number, col: number) => {
    const isSelected = selectedCell?.row === row && selectedCell?.col === col;
    const isRelated = isCellInSameRowOrColOrBox(row, col);
    const cellValue = board[row][col];
    const cellNotes = notes[row][col];
    const cage = getCageForCell(row, col);
    const isCageFirst = cage?.cells[0][0] === row && cage?.cells[0][1] === col;
    const opacity = highlightAnims[row][col];

    return (
      <TouchableOpacity
        key={`${row}-${col}`}
        style={styles.cellWrapper}
        onPress={() => handleCellPress(row, col)}
        activeOpacity={0.9}
      >
        <Animated.View
          style={[
            StyleSheet.absoluteFill,
            {
              backgroundColor: opacity.interpolate({
                inputRange: [0, 1],
                outputRange: ['#fff', '#ffeeba'], // tráº¯ng â†’ vÃ ng nháº¡t
              }),
              zIndex: 0,
            },
          ]}
          pointerEvents="none"
        />
        {isRelated && !isSelected && <View style={styles.relatedOverlay} />}
        {isSelected && <View style={styles.selectedOverlay} />}
        <View style={styles.cell}>
          {isCageFirst && <Text style={styles.cageText}>{cage?.sum}</Text>}
          {cellValue !== 0 ? (
            <Text style={[styles.cellText, cellValue === 0 && styles.placeholderText]}>
              {cellValue}
            </Text>
          ) : (
            <View style={styles.notesContainer}>
              {Array.from({ length: 9 }, (_, i) => (
                <Text key={i} style={styles.noteText}>
                  {cellNotes.includes((i + 1).toString()) ? i + 1 : ' '}
                </Text>
              ))}
            </View>
          )}
        </View>
      </TouchableOpacity>
    );
  };

  const handleHint = () => {
    if (!selectedCell) return;
    const { row, col } = selectedCell;
    // TODO: ThÃªm logic tá»± Ä‘á»™ng gá»£i Ã½
    console.log(`Hint cho Ã´ (${row}, ${col})`);
  };

  const buttons = [
    { label: 'Undo', icon: 'undo', onPress: handleUndo },
    { label: 'Erase', icon: 'eraser', onPress: handleClear },
    { label: 'Notes', icon: 'note-edit-outline', onPress: () => setNoteMode(!noteMode) },
    { label: 'Hint', icon: 'lightbulb-on-outline', onPress: handleHint },
  ];

  return (
    <View style={styles.container}>
      <View style={styles.gridWrapper}>
        {/* Grid sá»‘ */}
        <View style={styles.grid}>
          {board.map((row, rowIndex) => (
            <View key={rowIndex} style={styles.row}>
              {row.map((_, colIndex) => renderCell(rowIndex, colIndex))}
            </View>
          ))}
        </View>
        {/* Lá»›p SVG nÃ©t Ä‘á»©t - pháº£i Ä‘á»ƒ sau cÃ¹ng Ä‘á»ƒ luÃ´n náº±m trÃªn */}
        <Svg
          width={CELL_SIZE * BOARD_SIZE}
          height={CELL_SIZE * BOARD_SIZE}
          style={[
            StyleSheet.absoluteFill,
            { zIndex: 10 }
          ]} // Ä‘áº£m báº£o náº±m trÃªn cÃ¹ng
        >
          {renderCageOutlines()}
        </Svg>
      </View>

      {/* CÃ¡c button chá»©c nÄƒng */}
      <View style={{ flexDirection: 'row', justifyContent: 'space-around', width: 300, marginBottom: 12 }}>
        {buttons.map((btn, idx) => (
          <TouchableOpacity key={idx} onPress={btn.onPress} style={styles.actionButtonList}>
            <View style={{ marginBottom: 4 }}>
              {/* Thay báº±ng icon thá»±c táº¿ náº¿u cÃ³ */}
              {/* <Text style={{ fontSize: 18 }}>ðŸ’¡</Text> */}
              <MaterialCommunityIcons name={btn.icon} size={24} color="#333" style={{ marginBottom: 4 }} />
            </View>
            <Text>{btn.label}{btn.label === 'Notes' && noteMode ? ' (On)' : ''}</Text>
          </TouchableOpacity>
        ))}
      </View>

      {/* Number Input */}
      <View style={styles.numberPad}>
        {Array.from({ length: 9 }, (_, i) => i + 1).map((num) => (
          <TouchableOpacity key={num} style={styles.numberButton} onPress={() => handleNumberPress(num)}>
            <Text style={styles.numberText}>{num}</Text>
          </TouchableOpacity>
        ))}
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: '#fff',
  },
  gridWrapper: {
    width: CELL_SIZE * BOARD_SIZE,
    height: CELL_SIZE * BOARD_SIZE,
  },
  grid: {
    flexDirection: 'column',
    width: '100%',
    height: '100%',
  },
  row: {
    flexDirection: 'row',
  },
  cellWrapper: {
    width: CELL_SIZE,
    height: CELL_SIZE,
    position: 'relative',
  },
  selectedOverlay: {
    position: 'absolute',
    top: 0,
    left: 0,
    width: '100%',
    height: '100%',
    backgroundColor: '#d0e8ff',
    zIndex: 5,
  },
  cell: {
    flex: 1,
    borderWidth: 1,
    borderColor: '#000',
    justifyContent: 'center',
    alignItems: 'center',
    position: 'relative',
    zIndex: 20,
    backgroundColor: 'transparent'
  },
  relatedCell: {
    backgroundColor: '#f0f8ff',
    position: 'absolute',
    top: 0,
    left: 0,
    width: '100%',
    height: '100%',
    zIndex: 5,
  },
  cellText: {
    fontSize: 18,
    fontWeight: 'bold',
  },
  notesContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    justifyContent: 'center',
    alignItems: 'center',
  },
  noteText: {
    fontSize: 8,
    width: 10,
    textAlign: 'center',
    color: '#888',
  },
  cageText: {
    position: 'absolute',
    top: 2,
    left: 4,
    fontSize: 10,
    color: '#555',
  },
  numberPad: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    justifyContent: 'center',
  },
  numberButton: {
    width: 40,
    height: 40,
    borderRadius: 8,
    justifyContent: 'center',
    alignItems: 'center',
  },
  numberText: {
    fontSize: 24,
  },
  notesToggle: {
    marginTop: 16,
    padding: 10,
    borderRadius: 6,
    backgroundColor: '#dbeafe',
  },
  notesToggleText: {
    fontSize: 16,
    fontWeight: '500',
  },
  actionRow: {
    flexDirection: 'row',
    marginTop: 16,
  },
  actionButtonList: {
    alignItems: 'center',
    marginTop: 16,
    marginHorizontal: 12,
  },
  actionButton: {
    marginHorizontal: 12,
    padding: 10,
    backgroundColor: '#f3f4f6',
    borderRadius: 8,
  },
  placeholderText: {
    color: '#9ca3af', // gray-400
  },
  innerDashedOverlay: {
    ...StyleSheet.absoluteFillObject,
    pointerEvents: 'none',
  },
  relatedOverlay: {
    position: 'absolute',
    top: 0,
    left: 0,
    width: '100%',
    height: '100%',
    backgroundColor: '#f0f8ff',
    zIndex: 4,
  },
});

export default BoardScreen;
